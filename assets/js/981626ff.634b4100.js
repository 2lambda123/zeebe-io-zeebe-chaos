"use strict";(self.webpackChunkzell_chaos=self.webpackChunkzell_chaos||[]).push([[438],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=c(n),d=r,m=h["".concat(l,".").concat(d)]||h[d]||u[d]||o;return n?a.createElement(m,s(s({ref:t},p),{},{components:n})):a.createElement(m,s({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6821:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return p},toc:function(){return u},default:function(){return d}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),s=["components"],i={layout:"posts",title:"Recovery (Fail Over) time",date:new Date("2021-10-05T00:00:00.000Z"),categories:["chaos_experiment","fail_over"],tags:["availability"],authors:"zell"},l="Chaos Day Summary",c={permalink:"/zeebe-chaos/2021/10/05/recovery-time",editUrl:"https://github.com/zeebe-io/zeebe-chaos/blob/master/chaos-days/blog/2021-10-05-recovery-time/index.md",source:"@site/blog/2021-10-05-recovery-time/index.md",title:"Recovery (Fail Over) time",description:'In the last quarter we worked on a new "feature" which is called "building state on followers". In short,',date:"2021-10-05T00:00:00.000Z",formattedDate:"October 5, 2021",tags:[{label:"availability",permalink:"/zeebe-chaos/tags/availability"}],readingTime:4.355,truncated:!0,authors:[{name:"Christopher Zell",title:"Chaos Engineer @ Zeebe",url:"https://github.com/zelldon",imageURL:"https://github.com/zelldon.png",key:"zell"}],nextItem:{title:"Old-Clients",permalink:"/zeebe-chaos/2021/09/23/Old-Clients"}},p={authorsImageUrls:[void 0]},u=[{value:"First Chaos Experiment",id:"first-chaos-experiment",children:[{value:"Expected",id:"expected",children:[]},{value:"Actual",id:"actual",children:[]}]},{value:"Second Chaos Experiment",id:"second-chaos-experiment",children:[{value:"Expected",id:"expected-1",children:[]},{value:"Actual",id:"actual-1",children:[]}]},{value:"Running Instances",id:"running-instances",children:[]},{value:"Performance",id:"performance",children:[]}],h={toc:u};function d(e){var t=e.components,i=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},h,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,'In the last quarter we worked on a new "feature" which is called "building state on followers". In short,\nit means that the followers apply the events to build there state, which makes regular snapshot\nreplication unnecessary and allows faster role transition between Follower-to-Leader. In this chaos\nday I wanted to experiment a bit with this property, we already did some benchmarks ',(0,o.kt)("a",{parentName:"p",href:"https://github.com/camunda-cloud/zeebe/issues/7515"},"here"),".\nToday, I want to see how it behaves with larger state (bigger snapshots), since this needed to be\ncopied in previous versions of Zeebe, and the broker had to replay more than with the newest version."),(0,o.kt)("p",null,"If you want to now more about build state on followers check out the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/zeebe-io/enhancements/blob/master/ZEP007-build-state-on-followers.md"},"ZEP")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"TL;DR;")," In our experiment we had almost no downtime, with version 1.2, the new leader was very fast able to pick up the next work (accept new commands). "),(0,o.kt)("h2",{id:"first-chaos-experiment"},"First Chaos Experiment"),(0,o.kt)("p",null,"We will run two benchmarks one with 1.1 version and one with 1.2, to compare the differences between\nthe versions. We will run three brokers, with one partition and replication factor three. "),(0,o.kt)("p",null,"In order to build up state we run the ",(0,o.kt)("inlineCode",{parentName:"p"},"starter")," with a ",(0,o.kt)("inlineCode",{parentName:"p"},"durationLimit"),", example cfg:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"            value: >-\n              -Dapp.brokerUrl=zell-chaos-12-zeebe-gateway:26500\n              -Dapp.starter.rate=100\n              -Dapp.starter.durationLimit=1000\n              -Dzeebe.client.requestTimeout=62000\n              -XX:+HeapDumpOnOutOfMemoryError\n")),(0,o.kt)("p",null,'This means that we run a rate of 100 PI/s creations over 1000 seconds. We expect at the end around\n100.000 PI, which should be enough to simulate a "big state". '),(0,o.kt)("p",null,"After executing the starters we can see in the metrics the running instances:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"instances",src:n(8709).Z})),(0,o.kt)("p",null,"And that the snapshot is around 600 to 700 MB."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"snapshot",src:n(8629).Z})),(0,o.kt)("h3",{id:"expected"},"Expected"),(0,o.kt)("p",null,"We expect that if we restart the current leader that a new leader is fast (under seconds) able to\ntake over and continues the work. The version 1.2 should perform here much better than 1.1."),(0,o.kt)("h3",{id:"actual"},"Actual"),(0,o.kt)("p",null,"Just normal bootstrap takes some time, on version 1.1:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"base-start-up",src:n(6799).Z})),(0,o.kt)("p",null,"For version 1.2:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"12-start-up",src:n(6310).Z})),(0,o.kt)("p",null,"After running the starters for a certain duration and restarting the leader we can see that\nthe processor recovery takes by ",(0,o.kt)("em",{parentName:"p"},"factor 10")," longer on version 1.1. Unfortunately, we have not the\nleader transition metric in that version to compare against."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Version")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"1.1")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"1.2")))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Recovery"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("img",{alt:"base-recovery",src:n(3171).Z})),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("img",{alt:"12-recovery",src:n(9597).Z}))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"General"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("img",{alt:"base-recovery-general",src:n(4499).Z})),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("img",{alt:"12-recovery-general",src:n(8523).Z}))))),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Sorry for the small pictures")),(0,o.kt)("p",null,'In general what we have seen is that it is not so easy to compare if there is no longer load on the\nsystem, which is the reason I did a second experiment with: A) "big state" and B) steady load.'),(0,o.kt)("h2",{id:"second-chaos-experiment"},"Second Chaos Experiment"),(0,o.kt)("p",null,'Similar setup to the first experiment, but additionally after the "big state" is reached a steady\nload is put on the system. One starter with a rate of 100 PI/s and one worker completing some jobs.'),(0,o.kt)("p",null,"With that setup we want to verify how it affects the system if now a leader change happens."),(0,o.kt)("h3",{id:"expected-1"},"Expected"),(0,o.kt)("p",null,"Similar to above expect that if we restart the current leader that a new leader is fast\n(under seconds) able to take over and continues the work. The version 1.2 should perform here much\nbetter than 1.1."),(0,o.kt)("h3",{id:"actual-1"},"Actual"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Version")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"1.1")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"1.2")))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Recovery"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("img",{alt:"base-general-state-and-throughput-recover-time.png",src:n(6773).Z})),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("img",{alt:"12-general-state-and-throughput-recover-time.png",src:n(7042).Z}))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"General"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("img",{alt:"base-general-state-and-throughput-recover-general.png",src:n(6148).Z})),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("img",{alt:"12-general-state-and-throughput-recover-general.png",src:n(9692).Z}))))),(0,o.kt)("p",null,"After running the experiment again, this time with load, we can see that the version 1.1 took almost\n2 minutes! The newest Zeebe version (1.2), with building state on followers, took ~80 milliseconds!"),(0,o.kt)("p",null,"We can see this much better also in the processing and throughput metrics on version 1.1 we have ~2\nminutes gap."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"base-general-state-and-throughput-recover-general-zoom.png",src:n(9361).Z})),(0,o.kt)("p",null,"The exporters can recover a bit faster than the processing, but we are for a while not able to accept\nany commands."),(0,o.kt)("p",null,"In version 1.2 on the other hand we are able to almost immediately continue with the processing, some\nmetrics are not even able to show a gap in between, like the current events."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"12-general-state-and-throughput-recover-general-zoom.png",src:n(8806).Z})),(0,o.kt)("h1",{id:"result"},"Result"),(0,o.kt)("p",null,"In general, we were able to show that the new approach of building state on followers, gives us an\nexcellent benefit in transitioning between Follower and Leader. Furthermore, it allows us to handle\nmuch larger state, since this doesn't need to be replicated on a regular basis."),(0,o.kt)("h1",{id:"found-bugs"},"Found Bugs"),(0,o.kt)("h2",{id:"running-instances"},"Running Instances"),(0,o.kt)("p",null,"When experimenting with the clusters, building the state and deploying the steady load I\naccidentally deployed to many workers. This caused to complete all existing running instances. The\nissues here is that on the new leader the metric is zero, which results in a negative metric. "),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"broken-metric",src:n(8785).Z})),(0,o.kt)("p",null,"More problematic is actually that if you than build state again, you might reach the zero and if you\nobserve the cluster you can't be sure what the actual count of instances are. This makes the metric\nkind of useless."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"broken-metric",src:n(6438).Z})),(0,o.kt)("h2",{id:"performance"},"Performance"),(0,o.kt)("p",null,"During the experimenting it looked like that the performance of 1.2 degraded compared to 1.1. At the\nend I had on each benchmark one starter with 100 PI/s and one worker with capacity 12."),(0,o.kt)("p",null,"With version 1.1 it looked like we reached ~100 PI/s created/completed\n",(0,o.kt)("img",{alt:"base-general-state-and-throughput-recovery-general-perf.png",src:n(4691).Z})),(0,o.kt)("p",null,"With version 1.2 we just reached ~30, which means it reduced by factor 3.\n",(0,o.kt)("img",{alt:"12-general-state-and-throughput-recovery-general-perf.png",src:n(2446).Z})),(0,o.kt)("p",null,"I think we need to verify whether this is really the case."))}d.isMDXComponent=!0},2446:function(e,t,n){t.Z=n.p+"assets/images/12-general-state-and-throughput-recovery-general-perf-2e3b08a10dd42bd106818643de200518.png"},8806:function(e,t,n){t.Z=n.p+"assets/images/12-general-state-and-throughput-recovery-general-zoom-cbb1fd991e637f0f84eded0bcb33ba3f.png"},9692:function(e,t,n){t.Z=n.p+"assets/images/12-general-state-and-throughput-recovery-general-803fd268a252c919fb75fd5a0368a6a7.png"},7042:function(e,t,n){t.Z=n.p+"assets/images/12-general-state-and-throughput-recovery-time-25934f696f3d76a60017fd5c85dda9ea.png"},8523:function(e,t,n){t.Z=n.p+"assets/images/12-recovery-general-fa5b6920c1d994b36be40ee7130c86b0.png"},9597:function(e,t,n){t.Z=n.p+"assets/images/12-recovery-fadf67de59709ef23de1048730aa1fa6.png"},6310:function(e,t,n){t.Z=n.p+"assets/images/12-start-up-04e2050bd718b765993f07dc097b7678.png"},9361:function(e,t,n){t.Z=n.p+"assets/images/base-general-state-and-throughput-recover-general-zoom-346e51e9a7d1c8fd37a995dcf13ec030.png"},6148:function(e,t,n){t.Z=n.p+"assets/images/base-general-state-and-throughput-recover-general-494ebfac74f239ed6ab1e40c424e6719.png"},6773:function(e,t,n){t.Z=n.p+"assets/images/base-general-state-and-throughput-recover-time-b9c20296a6c02ab22b64a90c8e5b0f3a.png"},4691:function(e,t,n){t.Z=n.p+"assets/images/base-general-state-and-throughput-recovery-general-perf-cfb3b2c8bfa21e6c6499cda6b58d19f0.png"},4499:function(e,t,n){t.Z=n.p+"assets/images/base-recovery-general-71b7de7df76b17ee89efd539b6a3b5b3.png"},3171:function(e,t,n){t.Z=n.p+"assets/images/base-recovery-bee7a028446f8d3ee578efdcfb0ce458.png"},6799:function(e,t,n){t.Z=n.p+"assets/images/base-start-up-990e2a69500f27068362d59e86bedbdc.png"},6438:function(e,t,n){t.Z=n.p+"assets/images/broken-metric-zero-5d8e95304f288e82921bf536402882d5.png"},8785:function(e,t,n){t.Z=n.p+"assets/images/broken-metric-11b08dba5d36a8392efda2c2ebe5580d.png"},8709:function(e,t,n){t.Z=n.p+"assets/images/instances-8b991c2d040baa3627ded5a001ef43d1.png"},8629:function(e,t,n){t.Z=n.p+"assets/images/snapshot-73e2affb2bb52e3c38343994b6b7bf7f.png"}}]);