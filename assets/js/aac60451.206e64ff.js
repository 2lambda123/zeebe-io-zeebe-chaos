"use strict";(self.webpackChunkzell_chaos=self.webpackChunkzell_chaos||[]).push([[1804],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>m});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),h=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=h(e.components);return n.createElement(o.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=h(a),d=r,m=c["".concat(o,".").concat(d)]||c[d]||u[d]||l;return a?n.createElement(m,s(s({ref:t},p),{},{components:a})):n.createElement(m,s({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,s=new Array(l);s[0]=d;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i[c]="string"==typeof e?e:r,s[1]=i;for(var h=2;h<l;h++)s[h]=a[h];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},52558:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>h});var n=a(87462),r=(a(67294),a(3905));const l={layout:"posts",title:"High Snapshot Frequency",date:new Date("2022-02-01T00:00:00.000Z"),categories:["chaos_experiment","data"],tags:["availability"],authors:"zell"},s="Chaos Day Summary",i={permalink:"/zeebe-chaos/2022/02/01/High-Snapshot-Frequency",editUrl:"https://github.com/zeebe-io/zeebe-chaos/blob/master/chaos-days/blog/2022-02-01-High-Snapshot-Frequency/index.md",source:"@site/blog/2022-02-01-High-Snapshot-Frequency/index.md",title:"High Snapshot Frequency",description:"Today we wanted to experiment with the snapshot interval and verify that a high snapshot frequency will not impact our availability (#21).",date:"2022-02-01T00:00:00.000Z",formattedDate:"February 1, 2022",tags:[{label:"availability",permalink:"/zeebe-chaos/tags/availability"}],readingTime:3.52,hasTruncateMarker:!0,authors:[{name:"Christopher Zell",title:"Chaos Engineer @ Zeebe",url:"https://github.com/zelldon",imageURL:"https://github.com/zelldon.png",key:"zell"}],frontMatter:{layout:"posts",title:"High Snapshot Frequency",date:"2022-02-01T00:00:00.000Z",categories:["chaos_experiment","data"],tags:["availability"],authors:"zell"},prevItem:{title:"Standalone Gateway in CCSaaS",permalink:"/zeebe-chaos/2022/02/15/Standalone-Gateway-in-CCSaaS"},nextItem:{title:"Handling of Big Variables",permalink:"/zeebe-chaos/2022/01/19/big-variables"}},o={authorsImageUrls:[void 0]},h=[{value:"Chaos Experiment",id:"chaos-experiment",level:2},{value:"Snapshot Interval",id:"snapshot-interval",level:3},{value:"Expected",id:"expected",level:3},{value:"Actual",id:"actual",level:3},{value:"Smaller intervals",id:"smaller-intervals",level:4},{value:"Bigger intervals",id:"bigger-intervals",level:4},{value:"Result",id:"result",level:3},{value:"Found Bugs",id:"found-bugs",level:2}],p={toc:h},c="wrapper";function u(e){let{components:t,...l}=e;return(0,r.kt)(c,(0,n.Z)({},p,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Today we wanted to experiment with the snapshot interval and verify that a high snapshot frequency will not impact our availability (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/zeebe-io/zeebe-chaos/issues/21"},"#21"),")."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"TL;DR;")," The chaos experiment succeeded \ud83d\udcaa We were able to prove our hypothesis."),(0,r.kt)("h2",{id:"chaos-experiment"},"Chaos Experiment"),(0,r.kt)("h3",{id:"snapshot-interval"},"Snapshot Interval"),(0,r.kt)("p",null,"As we can see in the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.camunda.io/docs/self-managed/zeebe-deployment/operations/resource-planning/#snapshots"},"docs")," a snapshot is defined as:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"A snapshot is a projection of all events that represent the current running state of the processes running on the partition. It contains all active data, for example, deployed processes, active process instances, and not yet completed jobs.")),(0,r.kt)("p",null,"Per default snapshots are taken every 5 minutes, by leaders and followers. If a follower is lagging behind (with replication) the leader will, after reaching a certain threshold, prefer to send the follower a snapshot instead of replicating X amount of records. We recently observed that this currently happens quite often, see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/camunda-cloud/zeebe/issues/8565"},"#8565"),"."),(0,r.kt)("p",null,"The snapshot interval can be changed via an environment variable: ",(0,r.kt)("inlineCode",{parentName:"p"},"ZEEBE_BROKER_DATA_SNAPSHOTPERIOD")),(0,r.kt)("h3",{id:"expected"},"Expected"),(0,r.kt)("p",null,"We expect that even if the snapshot interval is low (so the frequency of taking snapshot is high) we not run into any availability issues and the cluster should still be healthy. Lower snapshot interval might impact the performance, since taking a snapshot can take some time but other than that it shouldn't have any effect."),(0,r.kt)("h3",{id:"actual"},"Actual"),(0,r.kt)("p",null,"As usual, we run again two benchmarks to compare them. One base which has the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/camunda-cloud/zeebe/tree/develop/benchmarks/setup/default"},"default benchmark configuration")," and one with a changed snapshot interval."),(0,r.kt)("p",null,"For the second benchmark we set the snapshot interval to one minute. Like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'env:\n  ...\n    - name: ZEEBE_BROKER_DATA_SNAPSHOTPERIOD\n    value: "1m"\n')),(0,r.kt)("p",null,"Throughput wise we can see a small difference, but this might be more related that on the base benchmark one node is leader for all partitions."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Base"),(0,r.kt)("th",{parentName:"tr",align:null},"Chaos"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("img",{src:a(45066).Z,width:"1842",height:"992"})),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("img",{src:a(13883).Z,width:"1834",height:"994"}))))),(0,r.kt)("p",null,"In general the cluster with the small snapshot interval shows no negative effect. What we can see is that the install request rate increased. It seems to be currently have no affect, but it is likely that if more partitions are added it might become an issue."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Base"),(0,r.kt)("th",{parentName:"tr",align:null},"Chaos"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("img",{src:a(80059).Z,width:"1832",height:"539"})),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("img",{src:a(44062).Z,width:"1831",height:"538"}))))),(0,r.kt)("p",null,"Further investigation needs to be done as part of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/camunda-cloud/zeebe/issues/8565"},"#8565"),"."),(0,r.kt)("h4",{id:"smaller-intervals"},"Smaller intervals"),(0,r.kt)("p",null,"The smallest interval which Zeebe supports is ",(0,r.kt)("inlineCode",{parentName:"p"},"1m == 1 minute"),". If we configure for example ",(0,r.kt)("inlineCode",{parentName:"p"},"1s")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'env:\n  ...\n    - name: ZEEBE_BROKER_DATA_SNAPSHOTPERIOD\n    value: "1s"\n')),(0,r.kt)("p",null,"We see the following exception in the log and the broker fails to start."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"java.lang.IllegalArgumentException: Snapshot period PT1S needs to be larger then or equals to one minute.\n")),(0,r.kt)("h4",{id:"bigger-intervals"},"Bigger intervals"),(0,r.kt)("p",null,"In order to verify how Zeebe reacts on a bigger snapshot interval we have set the interval to 30 minutes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'env:\n  ...\n    - name: ZEEBE_BROKER_DATA_SNAPSHOTPERIOD\n    value: "30m"\n')),(0,r.kt)("p",null,"In general, it looked good. What we can see is that one node was restarted in between and took a while to come back. "),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(16272).Z,width:"1840",height:"986"})),(0,r.kt)("p",null,"This is expected due to the high snapshot interval, but interesting to observe. The leader had no snapshot yet produced, which means it had to replicate all events to the restarted follower. Only if the follower catches up on all partitions its bootstrap process is complete, and it can mark itself as ready. As we see it can take a while if there is no snapshot available, since new records are incoming all the time. "),(0,r.kt)("p",null,"After the leader of partition two took a snapshot and the leader sent this snapshot to the follower, the follower were able to become ready."),(0,r.kt)("p",null,"Even with a big snapshot interval we can see that as soon as a new snapshot is taken it is sent to the followers, which is suboptimal."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(46036).Z,width:"2472",height:"274"})),(0,r.kt)("p",null,"An important thing to keep in mind when playing around with snapshots is the logstream/journal size. The journal is only compacted after taking a snapshot, if we take snapshot less frequent this means we clean up less frequent. The log can grow much bigger with big snapshot intervals."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(821).Z,width:"1219",height:"295"})),(0,r.kt)("h3",{id:"result"},"Result"),(0,r.kt)("p",null,"The chaos experiment succeeded \ud83c\udf89 We verified that a smaller snapshot interval has no negative impact on the cluster availability, at least for a small amount of partitions. "),(0,r.kt)("h2",{id:"found-bugs"},"Found Bugs"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Existing issue regarding the install requests ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/camunda-cloud/zeebe/issues/8565"},"#8565"))))}u.isMDXComponent=!0},16272:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/big-general-799179b5b7dc76032320f1a31488778f.png"},46036:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/big-install-freq-ec4ff83707c476e44d9469cc1969b106.png"},821:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/big-interval-log-84637b403e2e447d914fbf9fc386e164.png"},45066:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/chaos-base-general-93cd02e76e4ef0ed2125c457d5137ac0.png"},80059:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/chaos-base-install-freq-8110ca25fd510d004d558c30a6a75ad6.png"},13883:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/chaos-general-5d09330d3230f0843593e5384da1563f.png"},44062:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/chaos-install-freq-aea78deeffe000efe95cf1c111dade6f.png"}}]);